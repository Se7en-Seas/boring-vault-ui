import { Connection, PublicKey, TransactionInstruction } from '@solana/web3.js';

/**
 * Configuration for Switchboard oracle cranking
 */
export interface SwitchboardCrankConfig {
  /** Solana RPC connection */
  connection: Connection;
  /** Oracle feed address to crank */
  feedAddress: PublicKey;
  /** Wallet public key that will pay for the transaction */
  payer: PublicKey;
  /** Maximum staleness in seconds (optional, defaults to 300) */
  maxStaleness?: number;
  /** Number of signatures to require (optional, defaults to 1) */
  numSignatures?: number;
  /** Gateway URL (optional, defaults to Switchboard's mainnet gateway) */
  gateway?: string;
  /** Mock mode for testing (optional, defaults to false) */
  mockMode?: boolean;
}

/**
 * Creates a Switchboard oracle crank instruction that can be bundled with other instructions
 * 
 * This is a demo implementation that shows the structure for bundling.
 * In production, this would use the actual Switchboard SDK once version conflicts are resolved.
 * 
 * @param config Configuration for the Switchboard crank operation
 * @returns Promise<TransactionInstruction[] | null> - Returns array of instructions if update is needed, null if feed is fresh
 */
export async function getSwitchboardCrankInstruction(
  config: SwitchboardCrankConfig
): Promise<TransactionInstruction[] | null> {
  const { 
    connection, 
    feedAddress, 
    payer, 
    maxStaleness = 300, 
    numSignatures = 1,
    gateway = 'https://crossbar.switchboard.xyz',
    mockMode = false
  } = config;

  try {
    console.log(`Fetching Switchboard update for feed ${feedAddress.toString()}...`);
    
    if (mockMode) {
      // In mock mode, simulate the feed behavior without network calls
      console.log('Mock mode: Simulating feed check without network calls');
      
      // Simulate 70% chance that feed needs updating
      const needsUpdate = Math.random() < 0.7;
      
      if (!needsUpdate) {
        console.log(`Mock: Switchboard feed ${feedAddress.toString()} is fresh, no update needed`);
        return null;
      }
      
      console.log('Mock: Feed needs updating, generating demo instructions');
    } else {
      // Check if the feed exists on-chain
      const accountInfo = await connection.getAccountInfo(feedAddress);
      if (!accountInfo) {
        throw new Error(`Switchboard feed account ${feedAddress.toString()} not found`);
      }

      // For demo purposes, simulate checking if feed needs updating
      const needsUpdate = await simulateFeedStalenessCheck(connection, feedAddress, maxStaleness);
      
      if (!needsUpdate) {
        console.log(`Switchboard feed ${feedAddress.toString()} is fresh, no update needed`);
        return null;
      }
    }

    // Create demo instructions that would be generated by the Switchboard SDK
    // In production, these would be the actual secp256k1 verification and feed update instructions
    const instructions: TransactionInstruction[] = [
      // Instruction 1: secp256k1 signature verification
      new TransactionInstruction({
        programId: new PublicKey('KeccakSecp256k11111111111111111111111111111'), // secp256k1 program
        keys: [
          { pubkey: payer, isSigner: true, isWritable: true },
        ],
        data: Buffer.from('secp256k1_verify_demo', 'utf-8'), // Demo data
      }),
      
      // Instruction 2: Switchboard feed update
      new TransactionInstruction({
        programId: new PublicKey('SW1TCH7qEPTdLsDHRgPuMQjbQxKdH2aBStViMFnt64f'), // Switchboard program ID
        keys: [
          { pubkey: feedAddress, isSigner: false, isWritable: true },
          { pubkey: payer, isSigner: true, isWritable: true },
        ],
        data: Buffer.from('switchboard_update_demo', 'utf-8'), // Demo data
      }),
    ];

    console.log(`Generated ${instructions.length} demo Switchboard crank instructions for feed ${feedAddress.toString()}`);
    console.log('Note: These are demo instructions. In production, use the actual Switchboard SDK.');
    
    return instructions;

  } catch (error) {
    console.error('Error generating Switchboard crank instruction:', error);
    
    // If the error suggests the feed is fresh, return null rather than throwing
    if (error instanceof Error && error.message.includes('feed is fresh')) {
      console.log(`Switchboard feed ${feedAddress.toString()} is fresh, no update needed`);
      return null;
    }
    
    throw new Error(`Failed to generate Switchboard crank instruction: ${error}`);
  }
}

/**
 * Simulate checking if a feed needs updating based on staleness
 * In production, this would parse the actual feed account data
 */
async function simulateFeedStalenessCheck(
  connection: Connection,
  feedAddress: PublicKey,
  maxStaleness: number
): Promise<boolean> {
  try {
    // Get current slot
    const currentSlot = await connection.getSlot();
    
    // In a real implementation, we would:
    // 1. Parse the feed account data to get the last update slot
    // 2. Compare with current slot and staleness threshold
    // 3. Return true if stale, false if fresh
    
    // For demo purposes, assume feeds need updating periodically
    const shouldUpdate = (currentSlot % 100) < 50; // Simulate 50% chance of needing update
    
    console.log(`Demo staleness check: current slot ${currentSlot}, needs update: ${shouldUpdate}`);
    return shouldUpdate;
    
  } catch (error) {
    console.warn('Error in staleness check:', error);
    return true; // Assume needs update on error
  }
}

/**
 * Bundles Switchboard crank instruction with other instructions
 * 
 * @param config Switchboard configuration
 * @param otherInstructions Array of other instructions to bundle with
 * @returns Promise<TransactionInstruction[]> - Array of all instructions
 */
export async function bundleSwitchboardCrank(
  config: SwitchboardCrankConfig,
  otherInstructions: TransactionInstruction[]
): Promise<TransactionInstruction[]> {
  const crankInstructions = await getSwitchboardCrankInstruction(config);
  
  // If no crank instructions are needed, just return the other instructions
  if (!crankInstructions || crankInstructions.length === 0) {
    console.log('No Switchboard crank needed, proceeding with original instructions');
    return otherInstructions;
  }

  // Bundle the crank instructions at the beginning to ensure fresh price data
  console.log(`Bundling ${crankInstructions.length} Switchboard instructions with ${otherInstructions.length} other instructions`);
  return [...crankInstructions, ...otherInstructions];
}

/**
 * Utility function to check if a Switchboard feed needs updating
 * 
 * @param connection Solana connection
 * @param feedAddress Feed address to check
 * @param maxStaleness Maximum staleness in seconds
 * @returns Promise<boolean> - True if feed needs updating
 */
export async function needsSwitchboardUpdate(
  connection: Connection,
  feedAddress: PublicKey,
  maxStaleness: number = 300
): Promise<boolean> {
  try {
    return simulateFeedStalenessCheck(connection, feedAddress, maxStaleness);
    
  } catch (error) {
    console.warn('Error checking Switchboard feed staleness:', error);
    // If we can't check, assume it needs updating to be safe
    return true;
  }
}

/**
 * Utility function to get the current value from a Switchboard feed without updating it
 * 
 * @param connection Solana connection
 * @param feedAddress Feed address to read from
 * @returns Promise<{ value: number; slot: number } | null> - Current feed value or null if unavailable
 */
export async function getSwitchboardValue(
  connection: Connection,
  feedAddress: PublicKey
): Promise<{ value: number; slot: number } | null> {
  try {
    // Get account info to check if feed exists
    const accountInfo = await connection.getAccountInfo(feedAddress);
    if (!accountInfo) {
      console.warn(`Switchboard feed ${feedAddress.toString()} not found`);
      return null;
    }

    // In production, this would parse the actual feed account data
    // For demo purposes, return simulated values
    const currentSlot = await connection.getSlot();
    const simulatedPrice = 100 + Math.random() * 10; // Simulate price around $100-110
    
    console.log(`Demo feed value: $${simulatedPrice.toFixed(2)} at slot ${currentSlot}`);
    
    return {
      value: simulatedPrice,
      slot: currentSlot
    };
    
  } catch (error) {
    console.warn('Error reading Switchboard feed value:', error);
    return null;
  }
} 